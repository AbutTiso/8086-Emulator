use crate::util::preprocessor_util as util;
use util::{Label,LabelType};
use regex::{Regex,Captures};
use crate::preprocessor_error;
use lalrpop_util::ParseError;

// NOTES
// quote_ tokens are used for creating case ignoring names, as r"(capital case|small case)" generates ambiguity
//      if not this, either manually implement both with same code, else try r"(capital case|small case) " (with space)
//      but that can have issues as well
//
// name_string is a string that can be used for macro, function or label name, must start with _ or alphabet
// general_string is string that accepts nam_string, number, spaces, and square brackets [] 

grammar<'s>(context:&'s mut util::Context,out:&'s mut util::Output);

pub Code:() = {
    data_directives,
    code_directives,
    opcodes,
    Code opcodes
}

// ---------------------------------------------------------------------------------------------

// Assembler Data Directives

// Collective of all data directives
pub data_directives:() = {
    set_directive,
    db_directive,
    dw_directive,
    data_directives set_directive,
    data_directives db_directive,
    data_directives dw_directive,
}

// Set directive : used to set the DS value manually
set_directive:() = {
    quote_set <n:word_num> => {
        out.data.push(format!("set {}",n));
    }
}

quote_set:()={
    "set",
    "SET"
}

// DB directive
db_directive:() = {
    // Set single value with label
    <start:@L> <l:label> quote_db <n:byte_num> =>{
        context.label_map.insert(l,Label::new(LabelType::DATA,start as u16,context.data_counter));
        out.data.push(format!("db {}",n));
        // Increment the data counter
        context.data_counter += 1;
    },
    // Set single value without label
    quote_db <n:byte_num> =>{
        out.data.push(format!("db {}",n));
        // Increment the data counter
        context.data_counter += 1;
    },
    // Set array value initialized to 0 with label
    <start:@L> <l:label> quote_db "["<n:word_num>"]" =>{
        context.label_map.insert(l,Label::new(LabelType::DATA,start as u16,context.data_counter));
        out.data.push(format!("db [{}]",n));
        // Increment the data counter
        context.data_counter += n;
    },
    // Set array value initialized to 0 without label
    quote_db "[" <n:word_num>"]" =>{
        out.data.push(format!("db [{}]",n));
        // Increment the data counter
        context.data_counter += n;
    },
    // Set array value initialized to value with label
    <start:@L> <l:label> quote_db "["<n:word_num> ";" <v:byte_num>"]" =>{
        context.label_map.insert(l,Label::new(LabelType::DATA,start as u16,context.data_counter));
        out.data.push(format!("db [{} ; {}]",n,v));
        // Increment the data counter
        context.data_counter += n;
    },
    // Set array value initialized to value without label
    quote_db "[" <n:word_num> ";" <v:byte_num> "]" =>{
        out.data.push(format!("db [{} ; {}]",n,v));
        // Increment the data counter
        context.data_counter += n;
    },
}

quote_db:() = {
    "DB",
    "db",
}

// DW directive
dw_directive:() = {
    // Set single value with label
    <start:@L> <l:label> quote_dw <n:word_num> =>{
        context.label_map.insert(l,Label::new(LabelType::DATA,start as u16,context.data_counter));
        out.data.push(format!("dw {}",n));
        // Increment the data counter
        context.data_counter += 2;
    },
    // Set single value without label
    quote_dw <n:word_num> =>{
        out.data.push(format!("dw {}",n));
        // Increment the data counter
        context.data_counter += 2;
    },
    // Set array value initialized to 0 with label
    <start:@L> <l:label> quote_dw "["<n:word_num>"]" =>{
        context.label_map.insert(l,Label::new(LabelType::DATA,start as u16,context.data_counter));
        out.data.push(format!("dw [{}]",n));
        // Increment the data counter
        context.data_counter += 2*n;
    },
    // Set array value initialized to 0 without label
    quote_dw "[" <n:word_num>"]" =>{
        out.data.push(format!("dw [{}]",n));
        // Increment the data counter
        context.data_counter += 2*n;
    },
    // Set array value initialized to value with label
    <start:@L> <l:label> quote_dw "["<n:word_num> ";" <v:word_num>"]" =>{
        context.label_map.insert(l,Label::new(LabelType::DATA,start as u16,context.data_counter));
        out.data.push(format!("dw [{} ; {}]",n,v));
        // Increment the data counter
        context.data_counter += 2*n;
    },
    // Set array value initialized to value without label
    quote_dw "[" <n:word_num> ";" <v:word_num> "]" =>{
        out.data.push(format!("dw [{} ; {}]",n,v));
        // Increment the data counter
        context.data_counter += 2*n;
    },
}

quote_dw:() = {
    "dw",
    "DW"
}


// ---------------------------------------------------------------------------------------------

// Assembler code Directives

// Collective of all code directives
pub code_directives:() = {
    macro_def,
    macro_use,
    code_directives macro_def,
    code_directives macro_use,
}

// As lalrpop does not support optional token, and makes it an ambiguity error 
// if we use r"(MACRO|macro)" we will have to use this double declaration :(
// Closing bracket is counted and removed in raw_code
pub macro_def:() = {
    quote_macro <name:name_string> "(" <params:CommaSepList<name_string>> ")" "{" <r:raw_code> =>{
        let mut r = r.clone();
        // TODO Maybe optimise this later
        // maybe try making single regex of all params and replace, somehow
        for (i,p) in params.iter().enumerate(){
            let pat = format!(r"\b{}\b",p);
            let re = Regex::new(&pat).unwrap();
            r = re.replace_all(&r,|caps:&Captures|{
                format!("{{{}}}",i)
            }).to_string();
        }
        context.macro_map.insert(name,r);
    }
}

quote_macro:()={
    "MACRO",
    "macro"
}

raw_code:String = {
    <s:r"[_a-zA-Z0-9 \[\]]*}"> =>s[0..s.len()-2].to_owned()
}

macro_use:() = {
    <start:@L> <l:r"[_a-zA-Z][_a-zA-Z0-9]*"> "(" <params:CommaSepList<general_string>> ")" <end:@R> =>? {
        match context.macro_map.get(l){
            Some(value)=>{
                let mut r = value.clone();
                // TODO Maybe optimise this later
                // maybe try making single regex of all params and replace, somehow
                for (i,p) in params.iter().enumerate(){
                    let pat = format!("{{{}}}",i);
                    r = r.replace(&pat,&p);
                }
                let p = CodeParser::new();
                let o = p.parse(context,out,&r);
                match o{
                    Ok(_)=>Ok(()),
                    Err(e)=>{
                        // TODO better format error, maybe send the error position in formatted string as well?
                        preprocessor_error!(start,end,l,"Error in macro expansion".to_owned())
                    }
                }
            },
            None => preprocessor_error!(start as usize,start +l.len(),l,"Macro not defined".to_owned()),
        }
    }
}

// TODO def procedure
// TODO offset ?


// ---------------------------------------------------------------------------------------------


// Assembler opcodes
opcodes:()={
    control,
    transfer
}


// ----------------------------------
// Transfer Instructions

transfer:() = {
    call,
    ret,
    jmps_loops,
}


call:() = {
    <start:@L> quote_call <n:name_string> <end:@R> =>?{
        if !context.fn_set.contains(&n){
            return preprocessor_error!(start,end,"",format!("\'call\' can be only used with procedures, {} is not a procedure",n));
        }else{
            out.code.push(format!("call {}",n));
            return Ok(());
        }
    },
}
quote_call:()={
    "CALL",
    "call"
}

// Ret should be defined directly inside function definition
ret:() = {
    <start:@L> quote_ret <end:@R> =>?{
        preprocessor_error!(start,end,"ret","\'ret\' should be only used inside procedures".to_owned())
    }
}

quote_ret:() = {
    "RET",
    "ret"
}

// TODO support int ?
int:() = {
    <start:@L> quote_int <n:byte_num> <end:@R> =>?{
        preprocessor_error!(start,end,"int","\'int\' is not supported".to_owned())
    }
}

quote_int:() = {
    "INT",
    "int"
}

into_iret:() = {
    <start:@L> <q:quote_into_iret> <end:@R> =>?{
        preprocessor_error!(start,end,"",format!("\'{}\' is not supported",q))
    }
}

quote_into_iret:String = {
    "INTO" => "into".to_owned(),
    "into" => "into".to_owned(),
    "IRET" => "iret".to_owned(),
    "iret" => "iret".to_owned(),
}


// All jumps and loops are combined in single, as they have same syntax
jmps_loops:() = {
    <start:@L> <q:quote_jmps_loops> <n:name_string><end:@R> =>{
        out.code.push(format!("{} {}",q,n));
        if !context.label_map.contains_key(&n){
            context.undefined_labels.insert(n);
        }
    }
}

quote_jmps_loops:String = {
    "JMP" => "jmp".to_owned(),
    "jmp" => "jmp".to_owned(),
    "JA" => "ja".to_owned(),
    "ja" => "ja".to_owned(),
    "JNBE" => "jnbe".to_owned(),
    "jnbe" => "jnbe".to_owned(),
    "JAE" => "jae".to_owned(),
    "jae" => "jae".to_owned(),
    "JNB" => "jnb".to_owned(),
    "jnb" => "jnb".to_owned(),
    "JB" => "jb".to_owned(),
    "jb" => "jb".to_owned(),
    "JNAE" => "jnae".to_owned(),
    "jnae" => "jnae".to_owned(),
    "JBE" => "jbe".to_owned(),
    "jbe" => "jbe".to_owned(),
    "JNA" => "jna".to_owned(),
    "jna" => "jna".to_owned(),
    "JC" => "jc".to_owned(),
    "jc" => "jc".to_owned(),
    "JE" => "je".to_owned(),
    "je" => "je".to_owned(),
    "JZ" => "jz".to_owned(),
    "jz" => "jz".to_owned(),
    "JG" => "jg".to_owned(),
    "jg" => "jg".to_owned(),
    "JNLE" => "jnle".to_owned(),
    "jnle" => "jnle".to_owned(),
    "JGE" => "jge".to_owned(),
    "jge" => "jge".to_owned(),
    "JNL" => "jnl".to_owned(),
    "jnl" => "jnl".to_owned(),
    "JL" => "jl".to_owned(),
    "jl" => "jl".to_owned(),
    "JNGE" => "jnge".to_owned(),
    "jnge" => "jnge".to_owned(),
    "JLE" => "jle".to_owned(),
    "jle" => "jle".to_owned(),
    "JNG" => "jng".to_owned(),
    "jng" => "jng".to_owned(),
    "JNC" => "jnc".to_owned(),
    "jnc" => "jnc".to_owned(),
    "JNE" => "jne".to_owned(),
    "jne" => "jne".to_owned(),
    "JNZ" => "jnz".to_owned(),
    "jnz" => "jnz".to_owned(),
    "JNO" => "jno".to_owned(),
    "jno" => "jno".to_owned(),
    "JNP" => "jnp".to_owned(),
    "jnp" => "jnp".to_owned(),
    "JPO" => "jpo".to_owned(),
    "jpo" => "jpo".to_owned(),
    "JNS" => "jns".to_owned(),
    "jns" => "jns".to_owned(),
    "JO" => "jo".to_owned(),
    "jo" => "jo".to_owned(),
    "JP" => "jp".to_owned(),
    "jp" => "jp".to_owned(),
    "JPE" => "jpe".to_owned(),
    "jpe" => "jpe".to_owned(),
    "JS" => "js".to_owned(),
    "js" => "js".to_owned(),
    "LOOP" => "loop".to_owned(),
    "loop" => "loop".to_owned(),
    "LOOPE" => "loope".to_owned(),
    "loope" => "loope".to_owned(),
    "LOOPZ" => "loopz".to_owned(),
    "loopz" => "loopz".to_owned(),
    "LOOPNE" => "loopne".to_owned(),
    "loopne" => "loopne".to_owned(),
    "LOOPNZ" => "loopnz".to_owned(),
    "loopnz" => "loopnz".to_owned(),
    "JCXZ" => "jcxz".to_owned(),
    "jcxz" => "jcxz".to_owned(),
}

// ----------------------------------
// Control Instructions

control:()={
    ctc,
    clc,
    cmc,
    std,
    cld,
    sti,
    cli,
    hlt,
    wait,
    esc,
    lock,
    nop
}

ctc:()={
    "CTC" =>{out.code.push("ctc".to_owned());},
    "ctc" =>{out.code.push("ctc".to_owned());}
}
clc:()={
    "CLC" =>{out.code.push("clc".to_owned());},
    "clc" =>{out.code.push("clc".to_owned());}
}
cmc:()={
    "CMC" =>{out.code.push("cmc".to_owned());},
    "cmc" =>{out.code.push("cmc".to_owned());}
}
std:()={
    "STD" =>{out.code.push("std".to_owned());},
    "std" =>{out.code.push("std".to_owned());}
}
cld:()={
    "CLD" =>{out.code.push("cld".to_owned());},
    "cld" =>{out.code.push("cld".to_owned());}
}
sti:()={
    "STI" =>{out.code.push("sti".to_owned());},
    "sti" =>{out.code.push("sti".to_owned());}
}
cli:()={
    "CLI" =>{out.code.push("cli".to_owned());},
    "cli" =>{out.code.push("cli".to_owned());}
}
hlt:()={
    "HLT" =>{out.code.push("hlt".to_owned());},
    "hlt" =>{out.code.push("hlt".to_owned());}
}
wait:()={
    <start:@L> "WAIT" =>?preprocessor_error!(start,start+4,"WAIT","\'wait\' is not supported.".to_owned()),
    <start:@L> "wait" =>?preprocessor_error!(start,start+4,"wait","\'wait\' is not supported.".to_owned())
}
esc:()={
    <start:@L> "ESC" =>?preprocessor_error!(start,start+3,"ESC","\'esc\' is not supported.".to_owned()),
    <start:@L> "esc" =>?preprocessor_error!(start,start+3,"esc","\'esc\' is not supported.".to_owned())
}
lock:()={
    <start:@L> "LOCK" =>?preprocessor_error!(start,start+4,"LOCK","\'lock\' is not supported.".to_owned()),
    <start:@L> "lock" =>?preprocessor_error!(start,start+4,"lock","\'lock\' is not supported.".to_owned())
}
nop:()={
    <start:@L> "NOP" =>,
    <start:@L> "nop" =>
}


// ---------------------------------------------------------------------------------------------


// Low Level non-Terminals

// Label
// syntax : string immediately followed by a ':'
label:String = {
    <s:r"[_a-zA-Z][_a-zA-Z0-9]*:"> =>?{
        match context.label_map.get(&s[0..s.len()-2]){
            Some(l) => return preprocessor_error!(l.source_position as usize,l.source_position as usize+s.len(),s,"Label Already defined".to_owned()),
            None => Ok(s[0..s.len()-2].to_owned())
        }
    }
}


// Used to denote a 16-bit number
// can be a binary, decimal or hexadecimal number
// all are converted to u16
word_num: u16 = {
    // Decimal

    <start:@L> <n:r"[0-9]+"> <end:@R> =>? {
        match u16::from_str_radix(n,10){
            Ok(v) => Ok(v),
            Err(_) => preprocessor_error!(start,end,n,"Invalid Value, must be between 0-65535".to_owned())
        }
    },

    // hexadecimal
    <start:@L> <n:r"0(x|X)[0-9A-Fa-f]+"> <end:@R> =>? {
        match u16::from_str_radix(&n[2..],16){
            Ok(v) => Ok(v),
            Err(_) => preprocessor_error!(start,end,n,"Invalid Value, must be between 0-65535".to_owned())
        }
    },

    // Binary
    <start:@L> <n:r"0(b|B)[0-1]+"> <end:@R> =>? {
        match u16::from_str_radix(&n[2..],2){
            Ok(v) => Ok(v),
            Err(_) => preprocessor_error!(start,end,n,"Invalid Value, must be between 0-65535".to_owned())
        }
    }
}


// Used to denote a 8-bit number
// can be a binary, decimal or hexadecimal number
// all are converted to u16
byte_num: u8 = {
    // Decimal

    <start:@L> <n:r"[0-9]+"> <end:@R> =>? {
        match u8::from_str_radix(n,10){
            Ok(v) => Ok(v),
            Err(_) => preprocessor_error!(start,end,n,"Invalid Value, must be between 0-255".to_owned())
        }
    },

    // hexadecimal
    <start:@L> <n:r"0(x|X)[0-9A-Fa-f]+"> <end:@R> =>? {
        match u8::from_str_radix(&n[2..],16){
            Ok(v) => Ok(v),
            Err(_) => preprocessor_error!(start,end,n,"Invalid Value, must be between 0-255".to_owned())
        }
    },

    // Binary
    <start:@L> <n:r"0(b|B)[0-1]+"> <end:@R> =>? {
        match u8::from_str_radix(&n[2..],2){
            Ok(v) => Ok(v),
            Err(_) => preprocessor_error!(start,end,n,"Invalid Value, must be between 0-255".to_owned())
        }
    }
}

// ---------------------------------------------------------------------------------------------

// Helpers

CommaSepList<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

name_string:String ={
    <v:r"[_a-zA-Z][_a-zA-Z0-9]*"> =>{
        v.to_owned()
    }
}
general_string:String = {
    name_string,
    <n:word_num> =>format!("{}",n)
}